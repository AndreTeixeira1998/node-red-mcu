/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/*
	extacted from 17-split.js - only join
	
	- moved exports to top level
	- Standard ECMAScript module (not common JS)
	- disable / excise reduce (depends on JSonata)
	- move regexp preprocessing of joiner to nodered2mcu
	- move configuration initialization to nodered2mcu
	- use property getter/setter generated by noderedm2cu
	- use "b instanceof Uint8Array" instead of "Buffer.isBuffer(b)"
*/
 
function JoinNode(n) {
	RED.nodes.createNode(this,n);
	this.mode = n.mode;
	this.property = n.property;
	this.propertyType = n.propertyType;
	this.key = n.key;
	this.timer = (this.mode === "auto") ? 0 : Number(n.timeout || 0)*1000;
	this.count = n.count;
	this.joinerType = n.joinerType;
	this.setter = n.setter;
	this.getter = n.getter;

	if (this.joinerType === "bin") {
		var joinArray = JSON.parse(n.joiner || "[]");
		if (Array.isArray(joinArray)) {
			this.joiner = Buffer.from(joinArray);
		} else {
			throw new Error("not an array");
		}
	}

	this.build = n.build || "array";
	this.accumulate = n.accumulate || "false";

	this.output = n.output || "stream";
	this.pending = {};
	this.pending_count = 0;

	//this.topic = n.topic;
	var node = this;
	var inflight = {};

	var completeSend = function(partId) {
		var group = inflight[partId];
		if (group.timeout) { clearTimeout(group.timeout); }
		if ((node.accumulate !== true) || group.msg.hasOwnProperty("complete")) { delete inflight[partId]; }
		if (group.type === 'array' && group.arrayLen > 1) {
			var newArray = [];
			group.payload.forEach(function(n) {
				newArray = newArray.concat(n);
			})
			group.payload = newArray;
		}
		else if (group.type === 'buffer') {
			var buffers = [];
			var bufferLen = 0;
			if (group.joinChar !== undefined) {
				var joinBuffer = Buffer.from(group.joinChar);
				for (var i=0; i<group.payload.length; i++) {
					if (i > 0) {
						buffers.push(joinBuffer);
						bufferLen += joinBuffer.length;
					}
					if (!(group.payload[i] instanceof Uint8Array)) {
						group.payload[i] = Buffer.from(group.payload[i]);
					}
					buffers.push(group.payload[i]);
					bufferLen += group.payload[i].length;
				}
			}
			else {
				bufferLen = group.bufferLen;
				buffers = group.payload;
			}
			group.payload = Buffer.concat(buffers,bufferLen);
		}

		if (group.type === 'string') {
			var groupJoinChar = group.joinChar;
			if (typeof group.joinChar !== 'string') {
				groupJoinChar = group.joinChar.toString();
			}
//			RED.util.setMessageProperty(group.msg,node.property,group.payload.join(groupJoinChar));
			node.setter(group.msg,group.payload.join(groupJoinChar));
		}
		else {
			if (node.propertyType === 'full') {
				group.msg = RED.util.cloneMessage(group.msg);
			}
//			RED.util.setMessageProperty(group.msg,node.property,group.payload);
			node.setter(group.msg, group.payload);
		}
		if (group.msg.hasOwnProperty('parts') && group.msg.parts.hasOwnProperty('parts')) {
			group.msg.parts = group.msg.parts.parts;
		}
		else {
			delete group.msg.parts;
		}
		delete group.msg.complete;
		group.send(RED.util.cloneMessage(group.msg));
		group.dones.forEach(f => f());
		group.dones = [];
	}

	this.on("input", function(msg, send, done) {
		try {
			var property;
			var partId = "_";
			if (node.propertyType == "full") {
				property = msg;
			}
			else {
				try {
//					property = RED.util.getMessageProperty(msg,node.property);
					property = node.getter(msg);
				} catch(err) {
					node.warn("Message property "+node.property+" not found");
					done();
					return;
				}
			}

			if (node.mode === 'auto' && (!msg.hasOwnProperty("parts")||!msg.parts.hasOwnProperty("id"))) {
				// if a blank reset messag erest it all.
				if (msg.hasOwnProperty("reset")) {
					if (inflight && inflight.hasOwnProperty("partId") && inflight[partId].timeout) {
						clearTimeout(inflight[partId].timeout);
					}
					inflight = {};
				}
				else {
					node.warn("Message missing msg.parts property - cannot join in 'auto' mode")
				}
				done();
				return;
			}

			var payloadType;
			var propertyKey;
			var targetCount;
			var joinChar;
			var arrayLen;
			var propertyIndex;
			if (node.mode === "auto") {
				// Use msg.parts to identify all of the group information
				partId = msg.parts.id;
				payloadType = msg.parts.type;
				targetCount = msg.parts.count;
				joinChar = msg.parts.ch;
				propertyKey = msg.parts.key;
				arrayLen = msg.parts.len;
				propertyIndex = msg.parts.index;
			}
			else {
				// Use the node configuration to identify all of the group information
				payloadType = node.build;
				targetCount = node.count;
				joinChar = node.joiner;
				if (n.count === "" && msg.hasOwnProperty('parts')) {
					targetCount = msg.parts.count || 0;
				}
				if (node.build === 'object') {
					propertyKey = RED.util.getMessageProperty(msg,node.key);
				}
			}

			if (msg.hasOwnProperty("restartTimeout")) {
				if (inflight[partId]) {
					if (inflight[partId].timeout) {
						clearTimeout(inflight[partId].timeout);
					}
					if (node.timer > 0) {
						inflight[partId].timeout = setTimeout(function() {
							completeSend(partId)
						}, node.timer)
					}
				}
			}

			if (msg.hasOwnProperty("reset")) {
				if (inflight[partId]) {
					if (inflight[partId].timeout) {
						clearTimeout(inflight[partId].timeout);
					}
					inflight[partId].dones.forEach(f => f());
					delete inflight[partId]
				}
				done();
				return;
			}

			if ((payloadType === 'object') && (propertyKey === null || propertyKey === undefined || propertyKey === "")) {
				if (node.mode === "auto") {
					node.warn("Message missing 'msg.parts.key' property - cannot add to object");
				}
				else {
					if (msg.hasOwnProperty('complete')) {
						if (inflight[partId]) {
							inflight[partId].msg.complete = msg.complete;
							inflight[partId].send = send;
							completeSend(partId);
						}
					}
					else {
						node.warn("Message missing key property 'msg."+node.key+"' - cannot add to object")
					}
				}
				done();
				return;
			}

			if (!inflight.hasOwnProperty(partId)) {
				if (payloadType === 'object' || payloadType === 'merged') {
					inflight[partId] = {
						currentCount:0,
						payload:{},
						targetCount:targetCount,
						type:"object",
						msg:RED.util.cloneMessage(msg),
						send: send,
						dones: []
					};
				}
				else {
					inflight[partId] = {
						currentCount:0,
						payload:[],
						targetCount:targetCount,
						type:payloadType,
						msg:RED.util.cloneMessage(msg),
						send: send,
						dones: []
					};
					if (payloadType === 'string') {
						inflight[partId].joinChar = joinChar;
					} else if (payloadType === 'array') {
						inflight[partId].arrayLen = arrayLen;
					} else if (payloadType === 'buffer') {
						inflight[partId].bufferLen = 0;
						inflight[partId].joinChar = joinChar;
					}
				}
				if (node.timer > 0) {
					inflight[partId].timeout = setTimeout(function() {
						completeSend(partId)
					}, node.timer)
				}
			}
			inflight[partId].dones.push(done);

			var group = inflight[partId];
			if (payloadType === 'buffer') {
				if (property !== undefined) {
					if ((property instanceof Uint8Array) || (typeof property === "string") || Array.isArray(property)) {
						inflight[partId].bufferLen += property.length;
					}
					else {
						done(RED._("join.errors.invalid-type",{error:(typeof property)}));
						return;
					}
				}
			}
			if (payloadType === 'object') {
				group.payload[propertyKey] = property;
				group.currentCount = Object.keys(group.payload).length;
			} else if (payloadType === 'merged') {
				if (Array.isArray(property) || typeof property !== 'object') {
					if (!msg.hasOwnProperty("complete")) {
						node.warn("Cannot merge non-object types");
					}
				} else {
					for (propertyKey in property) {
						if (property.hasOwnProperty(propertyKey) && propertyKey !== '_msgid') {
							group.payload[propertyKey] = property[propertyKey];
						}
					}
					group.currentCount = Object.keys(group.payload).length;
					//group.currentCount++;
				}
			} else {
				if (!isNaN(propertyIndex)) {
					if (group.payload[propertyIndex] == undefined) { group.currentCount++; }
					group.payload[propertyIndex] = property;
				} else {
					if (property !== undefined) {
						group.payload.push(property);
						group.currentCount++;
					}
				}
			}
			group.msg = Object.assign(group.msg, msg);
			group.send = send;
			var tcnt = group.targetCount;
			if (msg.hasOwnProperty("parts")) {
				tcnt = group.targetCount || msg.parts.count;
				group.targetCount = tcnt;
			}
			if ((tcnt > 0 && group.currentCount >= tcnt) || msg.hasOwnProperty('complete')) {
				completeSend(partId);
			}
		}
		catch(err) {
			done(err);
			console.log(err.stack);
		}
	});

	this.on("close", function() {
		for (var i in inflight) {
			if (inflight.hasOwnProperty(i)) {
				clearTimeout(inflight[i].timeout);
				inflight[i].dones.forEach(d => d());
			}
		}
	});
}
RED.nodes.registerType("join",JoinNode);
